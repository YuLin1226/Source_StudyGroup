# Domain Driven Design
在做架構設計時，一個好的架構應該需要實現以下幾個目標：

- **獨立於框架：** 架構不應該依賴某個外部的庫或框架，不應該被框架的結構所束縛。
- **獨立於 UI：** 前臺展示的樣式可能會隨時發生變化（今天可能是網頁、明天可能變成 console、後天是獨立 app），但是底層架構不應該隨之而變化。
- **獨立於底層數據源：** 無論今天你用 MySQL、Oracle 還是 MongoDB、CouchDB，甚至使用文件系統，軟件架構不應該因爲不同的底層數據儲存方式而產生巨大改變。
- **獨立於外部依賴：** 無論外部依賴如何變更、升級，業務的核心邏輯不應該隨之而大幅變化。
- **可測試：** 無論外部依賴了什麼數據庫、硬件、UI 或者服務，業務的邏輯應該都能夠快速被驗證正確性。

> 程式設計的重點在於忠實解決業務的需求。

DDD 最大的價值之一就是把將商業領域的知識映照到程式碼中，解放「程式歸程式，業務歸業務」的傳統思維。廣泛來說， domain (knowledge) 是指「一塊知識的範圍」。實務上，就是指「你工作上所需的一切知識集合」，包含「問題」以及「解決方案」。
1. 跟領域專家 (domain expert) 密切合作來定義出 domain 的範圍及相關解決的方案。
2. 切分領域出數個子領域，並專注在核心子領域。
3. 透過一系列設計模式，將領域知識注入進程式模型 (model) 中。
---
## Example: 匯 500 元給用戶 A
Database-Driven Design
TransferController
transfer(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount)
1. 在介面輸入金額 500 與對象 A
2. 從DB讀取數據 (忽略所有檢驗邏輯如賬號是否存在等)
3. 確認我的帳戶餘額大於500元 (執行檢驗邏輯)
4. 我的帳戶減少500元 A帳戶增加500元
5. 更新DB

Database-Driven Design
而 2006 年的 JPA 標準，通過 @Entity 等註解，以及 Hibernate 等 ORM 框架的實現，讓很多 Java 開發對 Entity 的理解停留在了數據映射層面，忽略了 Entity 實體的本身行爲，造成今天很多的模型僅包含了實體的數據和屬性，而所有的業務邏輯都被分散在多個服務、Controller、Utils 工具類中，這個就是 Martin Fowler 所說的的 Anemic Domain Model（貧血領域模型）。

如何知道你的模型是貧血的呢？可以看一下你代碼中是否有以下的幾個特徵：

1. **有大量的 XxxDO 對象：** 這裏 DO 雖然有時候代表了 Domain Object，但實際上僅僅是數據庫表結構的映射，裏面沒有包含（或包含了很少的）業務邏輯；
2. **服務和 Controller 裏有大量的業務邏輯：** 比如校驗邏輯、計算邏輯、格式轉化邏輯、對象關係邏輯、數據存儲邏輯等；
3. 大量的 Utils 工具類等。
而貧血模型的缺陷是非常明顯的：
1. **無法保護模型對象的完整性和一致性：** 因爲對象的所有屬性都是公開的，只能由調用方來維護模型的一致性，而這個是沒有保障的；之前曾經出現的案例就是調用方沒有能維護模型數據的一致性，導致髒數據使用時出現 bug，這一類的 bug 還特別隱蔽，很難排查到。
2. **對象操作的可發現性極差：** 單純從對象的屬性上很難看出來都有哪些業務邏輯，什麼時候可以被調用，以及可以賦值的邊界是什麼；比如說，Long 類型的值是否可以是 0 或者負數？
3. **代碼邏輯重複：** 比如校驗邏輯、計算邏輯，都很容易出現在多個服務、多個代碼塊裏，提升維護成本和 bug 出現的概率；一類常見的 bug 就是當貧血模型變更後，校驗邏輯由於出現在多個地方，沒有能跟着變，導致校驗失敗或失效。
4. **代碼的健壯性差：** 比如一個數據模型的變化可能導致從上到下的所有代碼的變更。
5. **強依賴底層實現：** 業務代碼裏強依賴了底層數據庫、網絡 / 中間件協議、第三方服務等，造成核心邏輯代碼的僵化且維護成本高。

雖然貧血模型有很大的缺陷，但是在我們日常的代碼中，我見過的 99% 的代碼都是基於貧血模型，爲什麼呢？我總結了以下幾點：

1. **數據庫思維：** 從有了數據庫的那一天起，開發人員的思考方式就逐漸從 “寫業務邏輯“轉變爲了” 寫數據庫邏輯”，也就是我們經常說的在寫 CRUD 代碼。

2. **貧血模型 “簡單”：** 貧血模型的優勢在於 “簡單”，僅僅是對數據庫表的字段映射，所以可以從前到後用統一格式串通。這裏簡單打了引號，是因爲它只是表面上的簡單，實際上當未來有模型變更時，你會發現其實並不簡單，每次變更都是非常複雜的事情

3. **腳本思維：** 很多常見的代碼都屬於 “腳本” 或“膠水代碼”，也就是流程式代碼。腳本代碼的好處就是比較容易理解，但長久來看缺乏健壯性，維護成本會越來越高。

![](https://i.imgur.com/o1CDawA.png)

**AccountManagerService**
ApplicationService - TransferService
1. **[UserInterface]** 在介面輸入金額 500 與對象 A
2. **[Application]** 處理「匯款」的使用案例，呼叫 DB 取出我的帳戶與 A 的帳戶並啟動一個 Transaction (Transfer Service)。
3. **[Infrastructure]** DB 收到 Application 的指令完成任務
4. **[Application]** 將兩個帳戶轉換為 Domain 層的物件 (Account class) ，然後進行轉帳 (My_Account.TransferTo(A_Account, 500))
5. **[Domain]** 處理 My_Account.TransferTo(A_Account, 500) 的驗證(雙方帳戶狀態是否為開啟、餘額是否足夠)以及計算 (我扣 500，A 得 500 )。
6. **[Application]** 收到 My_Account.TransferTo(A_Account, 500) 成功的通知，將新的 Account 狀態存入 DB，然後送交 (commit) Transaction。
7. **[Infrastructure]** DB 執行 Application 來的指令。

**Challenge**
1. 換匯
2. 單日交易上限
3. 提現
4. 跨行交易

電子商務
1. 訂單
2. 庫存
3. 金流
4. 物流
5. 顧客

![alt text](https://i.imgur.com/HUHCqcl.png)
![alt text](https://i.imgur.com/pRs4IZN.png)
REF
[關於 Domain-Driven Design 以及他的魅力](https://ithelp.ithome.com.tw/articles/10216645)
[阿里技術專家詳解 DDD 系列 第二彈 - 應用架構](https://www.readfog.com/a/1630206911045537792)
[DDD系列第五讲:聊聊如何避免写流水账代码](https://juejin.cn/post/6953141151931039758)

